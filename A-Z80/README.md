# FPGA Implementation: A-Z80
Towards our goal of a realistic Game Gear representation, we intend to use an FPGA to replicate the Z80 and other boards such as the proprietary sound board. The [A-Z80](https://github.com/gdevic/A-Z80) does this, although it is somewhat outdated and does not have all of the functionality we need. However, it provides a full implementation of the Z80 along with some testing files. The implementation had to be updated from one that works on MAX II hardware to modern MAX 10 hardware (which is a jump from Quartus 13.0 to Quartus 23.1). As a result, the RAM and PLL (for the clock) had to be recreated in modern Quartus. Ultimately, this code is capable of converting a Z80 assembly file into a machine code memory initialization, synthesizing a memory and UART module, and then programming a DE10 Lite to replicate a Z80 that is running assembly code. The [provided test case](tools/zmac/hello_world.asm) is a "Hello World" implementation, which outputs printed statements over UART (in this case "CpE Design").

## How To Compile Assembly
1. Create and develop a Z80 assembly file in the [zmac folder](tools/zmac) (or use the provided [hello_world.asm](tools/zmac/hello_world.asm)).
2. Drag and drop the created assembly file onto [make_fpga.bat](tools/zmac/make_fpga.bat).
3. Proceed with synthesizing and programming below.

## How to Synthesize and Program the DE10 Lite
1. Open the DE10 Lite Quartus project located [here](host/basic_de1/basic_de1.qpf).
2. Ensure that the DE10 Lite development kit is selected as the board.
3. Ensure the pins are correctly assigned according to the [DE10 Lite manual](https://ftp.intel.com/Public/Pub/fpgaup/pub/Intel_Material/Boards/DE10-Lite/DE10_Lite_User_Manual.pdf).
4. Click the play sign at the top to perform synthesis, planning, and routing.
5. Open the Programmer and select the USB-Blaster device.
6. Remove the default file for programming and click add file. Then, navigate to output_files and select the .pof file.
7. Program the board.
8. Proceed to use the programmed FPGA.

## Using the Programmed FPGA (For the provided hello_world.asm)
- KEY0 will act as a reset, immediately resetting the programmed output (along with the counter).
- KEY1 will act as a non-maskable interrupt, spamming "IM2" and then continuing after KEY1 is released.
- The UART output can be visualized using a DAD board with WaveForms (through the 'protocol' menu), and will be on GPIO pin 6, with a baud rate of 115200, 8 data bits, 1 stop bit, no parity, and a CR LF as the end of line.

![UART Output](<README Images/UART.png>)
## Experimentation/Difficulties
I struggled significantly with getting the A-Z80 code to run on any other board. At first, I tried the OOTB MAX 10 FPGA that was provided in Digital Logic, but was not able to get it to run even after many hours of modification. Ultimately, I realized this was because the particular model we were using did not support memory intiialization, and thus it was not possible to create a RAM to store the assembly and machine code that needs to run on the Z80. While I could program the OOTB FPGA with the A-Z80, I could not get any assembly code to run. As a result, I had to track down a DE10 Lite board (from Digital Design), which has the capability to create a RAM, along with several other useful features such as having switches, buttons, and VGA>

However, even with the DE10 Lite, there were still significant struggles. For some reason the A-Z80 implementation was made with the DE1 board in mind, which is in the MAX II family. This is an archaic board that is only supported by archaic versions of Quartus (when it was still called Altera Quartus), and my modern version of Quartus basically just told me to it couldn't do anything with respect to converting. As a result, I had to dig through the files myself, install Quartus 13.0sp1 (wow it's so old), and try to understand how to best recreate the IP files (RAM and PLL) in modern Quartus. For a while, it was hard to tell whether the struggles I was having were due to improper configuration of the codebase, errors due to the conversion to MAX 10, or something else. This was a bit of a nightmare to debug, and at first I just focused on getting the ModelSim implementation to work (which actually didn't take too long). Then, I eventually managed to get the DE10 Lite to output something that seemed like UART, although it wasn't recognized by WaveForms. Eventually, I realized that the RAM was still improperly configured, and managed to get Hello World to successfully print. Since then, I have also explored the possibility of video output (particularly through VGA), but the issue is that the existing implementation of VGA bases its timings on 24 MHz and 27 MHz clocks that were present on the DE1 board. However, the DE10 only has 10 MHz and 50 MHz clocks, and the VGA protocol is extremely sensitive to timing. As a result, implementing VGA video output would be a very complex endeavour. Furthermore, we aren't planning on using VGA in our final solution, so we decided to instead focus on other interfaces like UART, SPI, and I2C that we would actually use for our screen.

## Known Bugs/History
Synthesis can be a bit finicky in Quartus, and so some errors may appear on different versions of Quartus or with different FPGAs other than the DE10 Lite. This code will not run on boards that are not in the MAX 10 family without a decent amount of modification. Getting the UART code to properly output was challenging, but I was finally able to do so after significant trouble with porting from MAX II (which modern versions of Quartus do not support and cannot convert) to MAX 10. Ultimately, I had to delete the IP files and recreate them with as similar of settings and initializations as I could, and it took some trial and error. Thus, porting to other families may be similarly difficult. When starting Quartus, it may prompt to overwrite or update the database file from another version of Quartus, and this is normal and can be accepted.
   Additionally, there were some issues modifying the [UART test code](tools/zmac/hello_world.asm) to add load instructions to store the string in memory instead of using db, since in many applications the data may be loaded instead of being constant before sending it to a communication protocol. When adding additional load instructions, instructions at the end of the function block were skipped preventing the whole string from loading. This is possibly an issue with the eZ80Acclaim IDE which was used for debugging, but it is more likely to be a logic error in the assembly.

